
Подход к выполнению тестового задания:
Считаю, что выполнения тестового не должно занимать более 6-8 часов.
Если тестовое задание требует большего времени, то
 - это уже не тестовое задание, а решение какой то бизнес-задачи
 - кандидат не обладает необходимыми навыками (Не справился).
 По этому, на решение тестового я заложил 6 часов.


Тестовое задание состоит из 2х частей.
Было необходимо детализировать затраченное время.

По 1 части:
Задачи не являются сложными. Большая часть времени ушла на осознание таблиц и данных в них.
Также, посчитал интересным - "Необходимо заполнить таблицы данными".
Конечно же можно было использовать insert into / values, но пожалуй, это слишком просто, и учитывая специфику задач,
в решении необходимо будет анализировать куда больше данных, чем можно "создать руками". По этому я реализовал отдельную процедуру для этого.
На реализацию процедуры ушло около 2х часов. (Хотя она достаточно простая, необходимо было постоянно её переделывать, что бы получать корректность данных в таблицах,
а именно, дата транзакции в orders не может быть совершена ранее, чем депозит на счет; то же самое и с депозитом, который не может быть ранее, чем регистрация пользователя, и тп.).
Итог по времени задача 1 ( до 3х часов):
- Создание процедуры: до 2 часов
- Решение последующих задач: до 1 часа.

Среда выполнения локальная бд Postgres. Скрипт можно запустить, всё будет работать ;). (Вот только учтите, у Вас может быть уже создана функция рандома)


Часть 2-ая

Конечно же на Java мог бы сделать решение более "красивым" за оставшееся время.
Но учитывая тот факт, что команда периодически работает с python, релевантным было бы решение сделать вторую задачу с помощью python. Так и решил.
Данный ход покажет в первую очередь мне, как быстро я смогу адаптироваться к рабочему стеку команды, во-вторую - показать команде обучаемость.

Краткая задача:
Необходимо сравнивать значения разных источников, обязательно БД, второй на выбор.
Вторым выбрал файл csv.
Реализация:
Сравнения решил сделать в буфере, т.к. сравнение на уровне БД было бы не показательным с точки зрения решения самой задачи.(Было больше SQL, и меньше Python).
Представим, что имеем в БД таблицу куда больше нежели файл для сравнения.
По этому нам необходимо достать те ID которые находятся в файле.
По этим ID забрать из таблицы данные.
Сравнить, не забывая запрос о толерансе.
Результат выдать в файл в формате(True - данные равны между собой, False - данные не равны):
UID COLUMN1 COLUMN2 COLUMN3
1   True    True    False
2   False   True    False



Создадим статическую таблицу на локальной Postgres.
И заполним тестовыми данными.
Create table TestCompareData
(
tranid  int,
dt date,
amt numeric(15,2)
comm varchar(100)
);
commit;


insert into TestCompareData
select 124, current_date-1, 2900.52, 'Get Test Text1' union
select 421, current_date-2, 4566.02, 'Get Test Text2' union
select 431, current_date-3, 4567.52, 'Get Test Text3' union
select 543, current_date, 756.52, 'Get Test Text4' union
select 754, current_date-1, 7635.52, 'Get Test Text5' union
select 522, current_date-3, 3457.04, 'Get Test Text6' union
select 654, current_date-4, 567.52, 'Get Test Text7' union
select 876, current_date-5, 786.52, 'Get Test Text8' union
select 765, current_date-23, 1200.45, 'Get Test Text9' union
select 896, current_date-2, 456.52, 'Get Test Text10' union
select 954, current_date, 757.52, 'Get Test Text11';
commit;

Так же создан csv файл с подобными данными. Данные изменены, чтобы проверять правильность сравнения. (файл отдельно закрепляю на github).
За оставшиеся 3 часа сделана задача, в результате получаем необходимый результат.
Оптимизация не проведена.
"Пакет" с аргументами "Путь к БД", "Путь к таблице" не создан.
Дальнейшие мысли по оптимизации:
1) "Обернуть" всё в пакет, настроить методы на прием файла/таблицы.
2) Динамический файл с результатами
3) Сравнение реализовать в разрезе даты, т.к. данных может быть больше, и буфер может переполняться.

Среда выполнения: Jupyter Notebook + Postgres
Если нет Jupyter Notebook, указываю последовательность установки:

pip install jupyterlab
export PATH="$HOME/.local/bin:$PATH"
pip install pandas
pip install psycopg2

# открываем, ищем в файловой системе файл с решением
jupyter-lab
